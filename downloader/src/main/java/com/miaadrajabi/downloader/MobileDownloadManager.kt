package com.miaadrajabi.downloader

import android.content.Context
import android.util.Log
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import kotlin.math.max
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import okhttp3.Call
import okhttp3.OkHttpClient

/**
 * 1. Core download queue manager stub that will be expanded in later steps.
 * 2. Holds the immutable DownloadConfig generated by the builder or direct input.
 */
class MobileDownloadManager private constructor(
    context: Context,
    private val config: DownloadConfig
) {

    private val appContext = context.applicationContext ?: context
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private val notificationHelper = DownloadNotificationHelper(appContext, config.notification)
    private val listeners: List<DownloadListener> = config.listeners + notificationHelper.listener
    private val storageResolver = StorageResolver(appContext, config.storage)
    private val scheduler = DownloadScheduler(appContext, config.scheduler)
    private val pendingDestinations = ConcurrentHashMap<String, StorageResolution>()
    private val activeSessions = ConcurrentHashMap<String, DownloadSession>()
    private val pausedStates = ConcurrentHashMap<String, PausedState>()
    private val chunkStateSnapshots = ConcurrentHashMap<String, MutableMap<Int, ChunkStateData>>()
    private val lastProgress = ConcurrentHashMap<String, Long>()
    private val httpClient = OkHttpClient()
    private val chunkedDownloader = ChunkedDownloader(httpClient)
    private val activeDownloads = AtomicInteger(0)

    init {
        DownloadNotificationRegistry.helper = notificationHelper
        DownloadManagerRegistry.manager = this
        DownloadConfigStore.save(appContext, config)
        restorePausedStates()
    }

    private fun restorePausedStates() {
        val restored = DownloadConfigStore.loadAllPausedStates(appContext)
        restored.forEach { pausedData ->
            val chunkList = pausedData.chunkStates
            val completed = if (chunkList.isNotEmpty()) {
                chunkList.totalCompletedBytes()
            } else {
                pausedData.completedBytes
            }
            pausedStates[pausedData.handleId] = PausedState(
                request = pausedData.request,
                resolution = pausedData.resolution,
                completedBytes = completed,
                chunkStates = chunkList
            )
            pendingDestinations[pausedData.handleId] = pausedData.resolution
            if (chunkList.isNotEmpty()) {
                chunkStateSnapshots[pausedData.handleId] =
                    chunkList.associateBy { it.index }.toMutableMap()
            }
            lastProgress[pausedData.handleId] = completed
        }
    }

    private fun currentChunkStates(handleId: String): List<ChunkStateData> {
        return chunkStateSnapshots[handleId]?.values
            ?.map { it.copy() }
            ?.sortedBy { it.index }
            ?: emptyList()
    }

    /**
     * 3. Exposes the immutable configuration for diagnostics and logging.
     */
    val configuration: DownloadConfig
        get() = config

    /**
     * 4. Adds a new download request to the active queue and starts transfer immediately.
     */
    fun enqueue(request: DownloadRequest): DownloadHandle {
        val resolution = storageResolver.resolve(request)
        pendingDestinations[request.id] = resolution

        activeDownloads.incrementAndGet()

        val handle = DownloadHandle(
            id = request.id,
            source = request.url
        )

        listeners.forEach { it.onQueued(handle) }
        val progressTrackingListener = object : DownloadListener {
            override fun onProgress(handle: DownloadHandle, progress: DownloadProgress) {
                lastProgress[handle.id] = progress.bytesDownloaded
            }
        }
        chunkStateSnapshots.remove(handle.id)
        val chunkStateUpdater: (ChunkStateData) -> Unit = { state ->
            val map = chunkStateSnapshots.getOrPut(handle.id) { ConcurrentHashMap() }
            map[state.index] = state
        }
        val session = DownloadSession(request, resolution, Job(), CallTracker())
        val job = scope.launch(session.job) {
            runDownloadWithRetry(
                request,
                handle,
                resolution,
                startOffset = 0L,
                callTracker = session.callTracker,
                extraListeners = listOf(progressTrackingListener),
                existingChunkStates = emptyList(),
                chunkStateUpdater = chunkStateUpdater
            )
        }
        activeSessions[handle.id] = session.copy(job = job)
        job.invokeOnCompletion {
            activeSessions.remove(handle.id)
            lastProgress.remove(handle.id)
            chunkStateSnapshots.remove(handle.id)
        }
        return handle
    }

    /**
     * 5. Provides visibility into where a request will land without mutating files.
     */
    fun previewDestination(request: DownloadRequest): StorageResolution {
        return storageResolver.resolve(request, dryRun = true)
    }

    /**
     * 6. Returns the prepared destination for an enqueued request, if available.
     */
    fun resolvedDestination(handleId: String): StorageResolution? {
        return pendingDestinations[handleId]
    }

    /**
     * 7. Schedules the request by leveraging WorkManager or AlarmManager.
     */
    fun schedule(request: DownloadRequest, scheduleTime: ScheduleTime? = config.scheduler.exactStartTime) {
        scheduler.schedule(request, scheduleTime)
    }

    /**
     * 8. Cancels any scheduled job associated with the request id.
     */
    fun cancelScheduled(handleId: String) {
        scheduler.cancel(handleId)
    }

    /**
     * 9. Attempts to pause an in-flight download. Returns true if a job was cancelled.
     */
    fun pause(handleId: String): Boolean {
        val session = activeSessions[handleId] ?: return false
        val chunkStates = currentChunkStates(handleId)
        val completedBytes = if (chunkStates.isNotEmpty()) {
            chunkStates.totalCompletedBytes()
        } else {
            lastProgress[handleId] ?: session.resolution.file.length()
        }
        pausedStates[handleId] = PausedState(
            request = session.request,
            resolution = session.resolution,
            completedBytes = completedBytes,
            chunkStates = chunkStates
        )
        DownloadConfigStore.savePausedState(
            appContext,
            handleId,
            session.request,
            session.resolution,
            completedBytes,
            chunkStates
        )
        val handle = DownloadHandle(handleId, session.request.url)
        session.job.cancel(CancellationException("Paused by user"))
        session.callTracker.cancelAll()
        listeners.forEach { it.onPaused(handle) }
        return true
    }

    /**
     * 10. Resumes a paused download from the last saved offset.
     */
    fun resume(handleId: String): Boolean {
        val paused = pausedStates.remove(handleId) ?: return false
        DownloadConfigStore.removePausedState(appContext, handleId)
        val handle = DownloadHandle(id = paused.request.id, source = paused.request.url)
        val progressTrackingListener = object : DownloadListener {
            override fun onProgress(handle: DownloadHandle, progress: DownloadProgress) {
                lastProgress[handle.id] = progress.bytesDownloaded
            }
        }
        val chunkStates = paused.chunkStates
        val resumeBytes = if (chunkStates.isNotEmpty()) {
            chunkStates.totalCompletedBytes()
        } else {
            paused.completedBytes
        }
        lastProgress[handleId] = resumeBytes
        chunkStateSnapshots[handleId] = chunkStates.associateBy { it.index }.toMutableMap()
        val chunkStateUpdater: (ChunkStateData) -> Unit = { state ->
            val map = chunkStateSnapshots.getOrPut(handleId) { ConcurrentHashMap() }
            map[state.index] = state
        }
        val session = DownloadSession(paused.request, paused.resolution, Job(), CallTracker())
        val job = scope.launch(session.job) {
            runDownloadWithRetry(
                paused.request,
                handle,
                paused.resolution,
                startOffset = resumeBytes,
                callTracker = session.callTracker,
                extraListeners = listOf(progressTrackingListener),
                existingChunkStates = chunkStates,
                chunkStateUpdater = chunkStateUpdater
            )
        }
        activeSessions[handleId] = session.copy(job = job)
        listeners.forEach { it.onResumed(handle) }
        job.invokeOnCompletion {
            activeSessions.remove(handleId)
            lastProgress.remove(handleId)
            chunkStateSnapshots.remove(handleId)
        }
        return true
    }

    /**
     * 11. Stops and forgets an active/paused download entirely.
     */
    fun stop(handleId: String): Boolean {
        val session = activeSessions.remove(handleId)
        if (session != null) {
            pausedStates.remove(handleId)
            pendingDestinations.remove(handleId)
            chunkStateSnapshots.remove(handleId)
            DownloadConfigStore.removePausedState(appContext, handleId)
            session.callTracker.cancelAll()
            session.job.cancel(CancellationException("Stopped by user"))
            return true
        }

        val paused = pausedStates.remove(handleId)
        if (paused != null) {
            pendingDestinations.remove(handleId)
            chunkStateSnapshots.remove(handleId)
            DownloadConfigStore.removePausedState(appContext, handleId)
            listeners.forEach { it.onCancelled(DownloadHandle(handleId, paused.request.url)) }
            markDownloadFinished()
            return true
        }

        return false
    }

    /**
     * 9. Shuts down resources and cancels background scope for cleanup.
     */
    fun shutdown() {
        scope.coroutineContext.cancel()
        DownloadManagerRegistry.manager = null
    }

    private suspend fun runDownloadWithRetry(
        request: DownloadRequest,
        handle: DownloadHandle,
        resolution: StorageResolution,
        startOffset: Long = 0L,
        callTracker: CallTracker? = null,
        extraListeners: List<DownloadListener> = emptyList(),
        existingChunkStates: List<ChunkStateData> = emptyList(),
        chunkStateUpdater: ((ChunkStateData) -> Unit)? = null
    ) {
        val policy = config.retryPolicy
        var attempt = 1
        var delayMs = policy.initialDelayMillis
        var shouldFinalize = true
        var plannedChunkStates = existingChunkStates
        var currentStartOffset = startOffset
        try {
            while (attempt <= policy.maxAttempts) {
                try {
                    val allListeners = listeners + extraListeners
                    allListeners.forEach { it.onStarted(handle) }
                    val downloadResult = chunkedDownloader.download(
                        request,
                        resolution,
                        handle,
                        config,
                        allListeners,
                        currentStartOffset,
                        callTracker,
                        plannedChunkStates,
                        chunkStateUpdater
                    )
                    
                    // Perform integrity validation if configured
                    if (config.integrity.verifyFileSize || 
                        config.integrity.verifyChecksum || 
                        config.integrity.verifyApkStructure ||
                        config.integrity.verifyContentType ||
                        config.integrity.verifyApkSignature) {
                        
                        val integrityResult = FileIntegrityVerifier.verifyFile(
                            file = resolution.file,
                            config = config.integrity,
                            request = request,
                            expectedSize = downloadResult.totalBytes,
                            contentType = downloadResult.contentType,
                            context = appContext
                        )
                        
                        if (!integrityResult.isValid) {
                            val errorMessage = "File integrity validation failed: ${integrityResult.errors.joinToString(", ")}"
                            Log.e("MobileDownloadManager", errorMessage)
                            
                            // Delete corrupted file before throwing exception
                            if (resolution.file.exists()) {
                                val deleted = resolution.file.delete()
                                if (deleted) {
                                    Log.d("MobileDownloadManager", "Deleted corrupted file: ${resolution.file.absolutePath}")
                                } else {
                                    Log.w("MobileDownloadManager", "Failed to delete corrupted file: ${resolution.file.absolutePath}")
                                }
                            }
                            
                            // Clear chunk states for retry from start
                            chunkStateSnapshots.remove(handle.id)
                            lastProgress.remove(handle.id)
                            
                            throw IntegrityValidationException(
                                message = errorMessage,
                                errors = integrityResult.errors,
                                file = resolution.file
                            )
                        }
                    }
                    
                    if (config.installer.promptOnCompletion) {
                        DownloadInstaller.maybePromptInstall(appContext, resolution.file, config.installer)
                    }
                    listeners.forEach { it.onCompleted(handle) }
                    pendingDestinations.remove(handle.id)
                    return
                } catch (error: IntegrityValidationException) {
                    // Integrity error: file already deleted, retry from start
                    if (attempt >= policy.maxAttempts) {
                        listeners.forEach { it.onFailed(handle, error) }
                        pendingDestinations.remove(handle.id)
                        return
                    } else {
                        listeners.forEach { it.onRetry(handle, attempt) }
                        // Reset states for retry from start (not resume)
                        plannedChunkStates = emptyList()
                        currentStartOffset = 0L
                        chunkStateSnapshots.remove(handle.id)
                        lastProgress.remove(handle.id)
                        delay(delayMs)
                        delayMs = (delayMs * policy.backoffMultiplier).toLong().coerceAtLeast(1_000L)
                        attempt++
                    }
                } catch (error: IOException) {
                    // Network error: keep file and resume from last position
                    if (attempt >= policy.maxAttempts) {
                        listeners.forEach { it.onFailed(handle, error) }
                        pendingDestinations.remove(handle.id)
                        return
                    } else {
                        listeners.forEach { it.onRetry(handle, attempt) }
                        // Resume from last position for network errors
                        plannedChunkStates = currentChunkStates(handle.id)
                        // Update startOffset based on current progress
                        val lastProgressBytes = lastProgress[handle.id] ?: 0L
                        currentStartOffset = if (lastProgressBytes > 0) lastProgressBytes else currentStartOffset
                        delay(delayMs)
                        delayMs = (delayMs * policy.backoffMultiplier).toLong().coerceAtLeast(1_000L)
                        attempt++
                    }
                } catch (cancel: CancellationException) {
                    val paused = pausedStates.containsKey(handle.id)
                    if (!paused) {
                        listeners.forEach { it.onCancelled(handle) }
                    }
                    shouldFinalize = !paused
                    return
                } catch (error: Throwable) {
                    listeners.forEach { it.onFailed(handle, error) }
                    pendingDestinations.remove(handle.id)
                    return
                }
            }
        } finally {
            if (shouldFinalize) {
                markDownloadFinished()
            }
        }
    }

    private fun markDownloadFinished() {
        val remaining = activeDownloads.decrementAndGet().coerceAtLeast(0)
        if (remaining <= 0) {
            DownloadNotificationRegistry.helper?.cancel()
            DownloadForegroundService.stopService(appContext)
        }
    }

    companion object {
        /**
         * 10. Creates an instance directly from a DownloadConfig.
         */
        fun create(context: Context, config: DownloadConfig = DownloadConfig()): MobileDownloadManager {
            return MobileDownloadManager(context, config)
        }

        /**
         * 11. Creates an instance using the fluent builder DSL.
         */
        fun create(context: Context, block: DownloadManagerBuilder.() -> Unit): MobileDownloadManager {
            return DownloadManagerBuilder(context).apply(block).build()
        }

        /**
         * 12. Exposes the builder for scenarios that need deferred building.
         */
        fun builder(context: Context): DownloadManagerBuilder {
            return DownloadManagerBuilder(context)
        }
    }
}

private data class DownloadSession(
    val request: DownloadRequest,
    val resolution: StorageResolution,
    val job: Job,
    val callTracker: CallTracker = CallTracker()
)

private data class PausedState(
    val request: DownloadRequest,
    val resolution: StorageResolution,
    val completedBytes: Long,
    val chunkStates: List<ChunkStateData>
)

internal class CallTracker {
    private val calls = ConcurrentHashMap.newKeySet<Call>()

    fun register(call: Call) {
        calls += call
    }

    fun cancelAll() {
        calls.forEach { it.cancel() }
        calls.clear()
    }
}

private fun List<ChunkStateData>.totalCompletedBytes(): Long {
    return sumOf { state ->
        max(0L, state.nextOffset - state.start)
    }
}

