package com.miaadrajabi.downloader

import android.content.Context
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import okhttp3.Call
import okhttp3.OkHttpClient

/**
 * 1. Core download queue manager stub that will be expanded in later steps.
 * 2. Holds the immutable DownloadConfig generated by the builder or direct input.
 */
class MobileDownloadManager private constructor(
    context: Context,
    private val config: DownloadConfig
) {

    private val appContext = context.applicationContext ?: context
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private val notificationHelper = DownloadNotificationHelper(appContext, config.notification)
    private val listeners: List<DownloadListener> = config.listeners + notificationHelper.listener
    private val storageResolver = StorageResolver(appContext, config.storage)
    private val scheduler = DownloadScheduler(appContext, config.scheduler)
    private val pendingDestinations = ConcurrentHashMap<String, StorageResolution>()
    private val activeSessions = ConcurrentHashMap<String, DownloadSession>()
    private val pausedStates = ConcurrentHashMap<String, PausedState>()
    private val httpClient = OkHttpClient()
    private val chunkedDownloader = ChunkedDownloader(httpClient)
    private val activeDownloads = AtomicInteger(0)

    init {
        DownloadNotificationRegistry.helper = notificationHelper
        DownloadManagerRegistry.manager = this
        DownloadConfigStore.save(appContext, config)
    }

    /**
     * 3. Exposes the immutable configuration for diagnostics and logging.
     */
    val configuration: DownloadConfig
        get() = config

    /**
     * 4. Adds a new download request to the active queue and starts transfer immediately.
     */
    fun enqueue(request: DownloadRequest): DownloadHandle {
        val resolution = storageResolver.resolve(request)
        pendingDestinations[request.id] = resolution

        activeDownloads.incrementAndGet()

        val handle = DownloadHandle(
            id = request.id,
            source = request.url
        )

        listeners.forEach { it.onQueued(handle) }
        val session = DownloadSession(request, resolution, Job(), CallTracker())
        val job = scope.launch(session.job) {
            runDownloadWithRetry(request, handle, resolution, callTracker = session.callTracker)
        }
        activeSessions[handle.id] = session.copy(job = job)
        job.invokeOnCompletion {
            activeSessions.remove(handle.id)
        }
        return handle
    }

    /**
     * 5. Provides visibility into where a request will land without mutating files.
     */
    fun previewDestination(request: DownloadRequest): StorageResolution {
        return storageResolver.resolve(request, dryRun = true)
    }

    /**
     * 6. Returns the prepared destination for an enqueued request, if available.
     */
    fun resolvedDestination(handleId: String): StorageResolution? {
        return pendingDestinations[handleId]
    }

    /**
     * 7. Schedules the request by leveraging WorkManager or AlarmManager.
     */
    fun schedule(request: DownloadRequest, scheduleTime: ScheduleTime? = config.scheduler.exactStartTime) {
        scheduler.schedule(request, scheduleTime)
    }

    /**
     * 8. Cancels any scheduled job associated with the request id.
     */
    fun cancelScheduled(handleId: String) {
        scheduler.cancel(handleId)
    }

    /**
     * 9. Attempts to pause an in-flight download. Returns true if a job was cancelled.
     */
    fun pause(handleId: String): Boolean {
        val session = activeSessions[handleId] ?: return false
        val file = session.resolution.file
        val completedBytes = file.length()
        pausedStates[handleId] = PausedState(session.request, session.resolution, completedBytes)
        val handle = DownloadHandle(handleId, session.request.url)
        session.job.cancel(CancellationException("Paused by user"))
        session.callTracker.cancelAll()
        listeners.forEach { it.onPaused(handle) }
        return true
    }

    /**
     * 10. Resumes a paused download from the last saved offset.
     */
    fun resume(handleId: String): Boolean {
        val paused = pausedStates[handleId] ?: return false
        val handle = DownloadHandle(id = paused.request.id, source = paused.request.url)
        pausedStates.remove(handleId)
        activeDownloads.incrementAndGet()
        val session = DownloadSession(paused.request, paused.resolution, Job(), CallTracker())
        val job = scope.launch(session.job) {
            runDownloadWithRetry(
                paused.request,
                handle,
                paused.resolution,
                startOffset = paused.completedBytes,
                callTracker = session.callTracker
            )
        }
        activeSessions[handleId] = session.copy(job = job)
        listeners.forEach { it.onResumed(handle) }
        job.invokeOnCompletion {
            activeSessions.remove(handleId)
        }
        return true
    }

    /**
     * 11. Stops and forgets an active/paused download entirely.
     */
    fun stop(handleId: String): Boolean {
        val session = activeSessions.remove(handleId)
        session?.callTracker?.cancelAll()
        session?.job?.cancel(CancellationException("Stopped by user"))
        pausedStates.remove(handleId)
        pendingDestinations.remove(handleId)
        return session != null
    }

    /**
     * 9. Shuts down resources and cancels background scope for cleanup.
     */
    fun shutdown() {
        scope.coroutineContext.cancel()
        DownloadManagerRegistry.manager = null
    }

    private suspend fun runDownloadWithRetry(
        request: DownloadRequest,
        handle: DownloadHandle,
        resolution: StorageResolution,
        startOffset: Long = 0L,
        callTracker: CallTracker? = null
    ) {
        val policy = config.retryPolicy
        var attempt = 1
        var delayMs = policy.initialDelayMillis
        try {
            while (attempt <= policy.maxAttempts) {
                try {
                    listeners.forEach { it.onStarted(handle) }
                    chunkedDownloader.download(request, resolution, handle, config, listeners, startOffset, callTracker)
                    if (config.installer.promptOnCompletion) {
                        DownloadInstaller.maybePromptInstall(appContext, resolution.file, config.installer)
                    }
                    listeners.forEach { it.onCompleted(handle) }
                    pendingDestinations.remove(handle.id)
                    return
                } catch (error: IOException) {
                    if (attempt >= policy.maxAttempts) {
                        listeners.forEach { it.onFailed(handle, error) }
                        pendingDestinations.remove(handle.id)
                        return
                    } else {
                        listeners.forEach { it.onRetry(handle, attempt) }
                        delay(delayMs)
                        delayMs = (delayMs * policy.backoffMultiplier).toLong().coerceAtLeast(1_000L)
                        attempt++
                    }
                } catch (cancel: CancellationException) {
                    if (!pausedStates.containsKey(handle.id)) {
                        listeners.forEach { it.onCancelled(handle) }
                    }
                    return
                } catch (error: Throwable) {
                    listeners.forEach { it.onFailed(handle, error) }
                    pendingDestinations.remove(handle.id)
                    return
                }
            }
        } finally {
            markDownloadFinished()
        }
    }

    private fun markDownloadFinished() {
        val remaining = activeDownloads.decrementAndGet().coerceAtLeast(0)
        if (remaining <= 0) {
            DownloadForegroundService.stopService(appContext)
        }
    }

    companion object {
        /**
         * 10. Creates an instance directly from a DownloadConfig.
         */
        fun create(context: Context, config: DownloadConfig = DownloadConfig()): MobileDownloadManager {
            return MobileDownloadManager(context, config)
        }

        /**
         * 11. Creates an instance using the fluent builder DSL.
         */
        fun create(context: Context, block: DownloadManagerBuilder.() -> Unit): MobileDownloadManager {
            return DownloadManagerBuilder(context).apply(block).build()
        }

        /**
         * 12. Exposes the builder for scenarios that need deferred building.
         */
        fun builder(context: Context): DownloadManagerBuilder {
            return DownloadManagerBuilder(context)
        }
    }
}

private data class DownloadSession(
    val request: DownloadRequest,
    val resolution: StorageResolution,
    val job: Job,
    val callTracker: CallTracker = CallTracker()
)

private data class PausedState(
    val request: DownloadRequest,
    val resolution: StorageResolution,
    val completedBytes: Long
)

internal class CallTracker {
    private val calls = ConcurrentHashMap.newKeySet<Call>()

    fun register(call: Call) {
        calls += call
    }

    fun cancelAll() {
        calls.forEach { it.cancel() }
        calls.clear()
    }
}

